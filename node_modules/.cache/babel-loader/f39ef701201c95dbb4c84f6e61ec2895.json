{"remainingRequest":"/Applications/lg_web/yupuhu/node_modules/thread-loader/dist/cjs.js!/Applications/lg_web/yupuhu/node_modules/babel-loader/lib/index.js!/Applications/lg_web/yupuhu/src/assets/js/common/pinchzoom.js","dependencies":[{"path":"/Applications/lg_web/yupuhu/src/assets/js/common/pinchzoom.js","mtime":1563783944679},{"path":"/Applications/lg_web/yupuhu/node_modules/cache-loader/dist/cjs.js","mtime":1561083984975},{"path":"/Applications/lg_web/yupuhu/node_modules/thread-loader/dist/cjs.js","mtime":1561083989993},{"path":"/Applications/lg_web/yupuhu/node_modules/babel-loader/lib/index.js","mtime":1561083931133}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.find\";\n(function () {\n  'use strict';\n\n  var definePinchZoom = function definePinchZoom($) {\n    var PinchZoom = function PinchZoom(el, options) {\n      this.el = $(el);\n      this.zoomFactor = 1;\n      this.lastScale = 1;\n      this.offset = {\n        x: 0,\n        y: 0\n      };\n      this.options = $.extend({}, this.defaults, options);\n      this.setupMarkup();\n      this.bindEvents();\n      this.update();\n      this.enable();\n    },\n        sum = function sum(a, b) {\n      return a + b;\n    },\n        isCloseTo = function isCloseTo(value, expected) {\n      return value > expected - 0.01 && value < expected + 0.01;\n    };\n\n    PinchZoom.prototype = {\n      defaults: {\n        tapZoomFactor: 2,\n        zoomOutFactor: 1.3,\n        animationDuration: 300,\n        maxZoom: 4,\n        minZoom: 0.5,\n        lockDragAxis: false,\n        use2d: true,\n        zoomStartEventName: 'pz_zoomstart',\n        zoomEndEventName: 'pz_zoomend',\n        dragStartEventName: 'pz_dragstart',\n        dragEndEventName: 'pz_dragend',\n        doubleTapEventName: 'pz_doubletap'\n      },\n      handleDragStart: function handleDragStart(event) {\n        this.el.trigger(this.options.dragStartEventName);\n        this.stopAnimation();\n        this.lastDragPosition = false;\n        this.hasInteraction = true;\n        this.handleDrag(event);\n      },\n      handleDrag: function handleDrag(event) {\n        if (this.zoomFactor > 1.0) {\n          var touch = this.getTouches(event)[0];\n          this.drag(touch, this.lastDragPosition);\n          this.offset = this.sanitizeOffset(this.offset);\n          this.lastDragPosition = touch;\n        }\n      },\n      handleDragEnd: function handleDragEnd() {\n        this.el.trigger(this.options.dragEndEventName);\n        this.end();\n      },\n      handleZoomStart: function handleZoomStart(event) {\n        this.el.trigger(this.options.zoomStartEventName);\n        this.stopAnimation();\n        this.lastScale = 1;\n        this.nthZoom = 0;\n        this.lastZoomCenter = false;\n        this.hasInteraction = true;\n      },\n      handleZoom: function handleZoom(event, newScale) {\n        var touchCenter = this.getTouchCenter(this.getTouches(event)),\n            scale = newScale / this.lastScale;\n        this.lastScale = newScale;\n        this.nthZoom += 1;\n\n        if (this.nthZoom > 3) {\n          this.scale(scale, touchCenter);\n          this.drag(touchCenter, this.lastZoomCenter);\n        }\n\n        this.lastZoomCenter = touchCenter;\n      },\n      handleZoomEnd: function handleZoomEnd() {\n        this.el.trigger(this.options.zoomEndEventName);\n        this.end();\n      },\n      handleDoubleTap: function handleDoubleTap(event) {\n        var center = this.getTouches(event)[0],\n            zoomFactor = this.zoomFactor > 1 ? 1 : this.options.tapZoomFactor,\n            startZoomFactor = this.zoomFactor,\n            updateProgress = function (progress) {\n          this.scaleTo(startZoomFactor + progress * (zoomFactor - startZoomFactor), center);\n        }.bind(this);\n\n        if (this.hasInteraction) {\n          return;\n        }\n\n        if (startZoomFactor > zoomFactor) {\n          center = this.getCurrentZoomCenter();\n        }\n\n        this.animate(this.options.animationDuration, updateProgress, this.swing);\n        this.el.trigger(this.options.doubleTapEventName);\n      },\n      sanitizeOffset: function sanitizeOffset(offset) {\n        var maxX = (this.zoomFactor - 1) * this.getContainerX(),\n            maxY = (this.zoomFactor - 1) * this.getContainerY(),\n            maxOffsetX = Math.max(maxX, 0),\n            maxOffsetY = Math.max(maxY, 0),\n            minOffsetX = Math.min(maxX, 0),\n            minOffsetY = Math.min(maxY, 0);\n        return {\n          x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),\n          y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)\n        };\n      },\n      scaleTo: function scaleTo(zoomFactor, center) {\n        this.scale(zoomFactor / this.zoomFactor, center);\n      },\n      scale: function scale(_scale, center) {\n        _scale = this.scaleZoomFactor(_scale);\n        this.addOffset({\n          x: (_scale - 1) * (center.x + this.offset.x),\n          y: (_scale - 1) * (center.y + this.offset.y)\n        });\n      },\n      scaleZoomFactor: function scaleZoomFactor(scale) {\n        var originalZoomFactor = this.zoomFactor;\n        this.zoomFactor *= scale;\n        this.zoomFactor = Math.min(this.options.maxZoom, Math.max(this.zoomFactor, this.options.minZoom));\n        return this.zoomFactor / originalZoomFactor;\n      },\n      drag: function drag(center, lastCenter) {\n        if (lastCenter) {\n          if (this.options.lockDragAxis) {\n            if (Math.abs(center.x - lastCenter.x) > Math.abs(center.y - lastCenter.y)) {\n              this.addOffset({\n                x: -(center.x - lastCenter.x),\n                y: 0\n              });\n            } else {\n              this.addOffset({\n                y: -(center.y - lastCenter.y),\n                x: 0\n              });\n            }\n          } else {\n            this.addOffset({\n              y: -(center.y - lastCenter.y),\n              x: -(center.x - lastCenter.x)\n            });\n          }\n        }\n      },\n      getTouchCenter: function getTouchCenter(touches) {\n        return this.getVectorAvg(touches);\n      },\n      getVectorAvg: function getVectorAvg(vectors) {\n        return {\n          x: vectors.map(function (v) {\n            return v.x;\n          }).reduce(sum) / vectors.length,\n          y: vectors.map(function (v) {\n            return v.y;\n          }).reduce(sum) / vectors.length\n        };\n      },\n      addOffset: function addOffset(offset) {\n        this.offset = {\n          x: this.offset.x + offset.x,\n          y: this.offset.y + offset.y\n        };\n      },\n      sanitize: function sanitize() {\n        if (this.zoomFactor < this.options.zoomOutFactor) {\n          this.zoomOutAnimation();\n        } else if (this.isInsaneOffset(this.offset)) {\n          this.sanitizeOffsetAnimation();\n        }\n      },\n      isInsaneOffset: function isInsaneOffset(offset) {\n        var sanitizedOffset = this.sanitizeOffset(offset);\n        return sanitizedOffset.x !== offset.x || sanitizedOffset.y !== offset.y;\n      },\n      sanitizeOffsetAnimation: function sanitizeOffsetAnimation() {\n        var targetOffset = this.sanitizeOffset(this.offset),\n            startOffset = {\n          x: this.offset.x,\n          y: this.offset.y\n        },\n            updateProgress = function (progress) {\n          this.offset.x = startOffset.x + progress * (targetOffset.x - startOffset.x);\n          this.offset.y = startOffset.y + progress * (targetOffset.y - startOffset.y);\n          this.update();\n        }.bind(this);\n\n        this.animate(this.options.animationDuration, updateProgress, this.swing);\n      },\n      zoomOutAnimation: function zoomOutAnimation() {\n        var startZoomFactor = this.zoomFactor,\n            zoomFactor = 1,\n            center = this.getCurrentZoomCenter(),\n            updateProgress = function (progress) {\n          this.scaleTo(startZoomFactor + progress * (zoomFactor - startZoomFactor), center);\n        }.bind(this);\n\n        this.animate(this.options.animationDuration, updateProgress, this.swing);\n      },\n      updateAspectRatio: function updateAspectRatio() {\n        this.setContainerY(this.getContainerX() / this.getAspectRatio());\n      },\n      getInitialZoomFactor: function getInitialZoomFactor() {\n        return this.container[0].offsetWidth / this.el[0].offsetWidth;\n      },\n      getAspectRatio: function getAspectRatio() {\n        return this.el[0].offsetWidth / this.el[0].offsetHeight;\n      },\n      getCurrentZoomCenter: function getCurrentZoomCenter() {\n        var length = this.container[0].offsetWidth * this.zoomFactor,\n            offsetLeft = this.offset.x,\n            offsetRight = length - offsetLeft - this.container[0].offsetWidth,\n            widthOffsetRatio = offsetLeft / offsetRight,\n            centerX = widthOffsetRatio * this.container[0].offsetWidth / (widthOffsetRatio + 1),\n            height = this.container[0].offsetHeight * this.zoomFactor,\n            offsetTop = this.offset.y,\n            offsetBottom = height - offsetTop - this.container[0].offsetHeight,\n            heightOffsetRatio = offsetTop / offsetBottom,\n            centerY = heightOffsetRatio * this.container[0].offsetHeight / (heightOffsetRatio + 1);\n\n        if (offsetRight === 0) {\n          centerX = this.container[0].offsetWidth;\n        }\n\n        if (offsetBottom === 0) {\n          centerY = this.container[0].offsetHeight;\n        }\n\n        return {\n          x: centerX,\n          y: centerY\n        };\n      },\n      canDrag: function canDrag() {\n        return !isCloseTo(this.zoomFactor, 1);\n      },\n      getTouches: function getTouches(event) {\n        var position = this.container.offset();\n        return Array.prototype.slice.call(event.touches).map(function (touch) {\n          return {\n            x: touch.pageX - position.left,\n            y: touch.pageY - position.top\n          };\n        });\n      },\n      animate: function animate(duration, framefn, timefn, callback) {\n        var startTime = new Date().getTime(),\n            renderFrame = function () {\n          if (!this.inAnimation) {\n            return;\n          }\n\n          var frameTime = new Date().getTime() - startTime,\n              progress = frameTime / duration;\n\n          if (frameTime >= duration) {\n            framefn(1);\n\n            if (callback) {\n              callback();\n            }\n\n            this.update();\n            this.stopAnimation();\n            this.update();\n          } else {\n            if (timefn) {\n              progress = timefn(progress);\n            }\n\n            framefn(progress);\n            this.update();\n            requestAnimationFrame(renderFrame);\n          }\n        }.bind(this);\n\n        this.inAnimation = true;\n        requestAnimationFrame(renderFrame);\n      },\n      stopAnimation: function stopAnimation() {\n        this.inAnimation = false;\n      },\n      swing: function swing(p) {\n        return -Math.cos(p * Math.PI) / 2 + 0.5;\n      },\n      getContainerX: function getContainerX() {\n        return this.container[0].offsetWidth;\n      },\n      getContainerY: function getContainerY() {\n        return this.container[0].offsetHeight;\n      },\n      setContainerY: function setContainerY(y) {\n        return this.container.height(y);\n      },\n      setupMarkup: function setupMarkup() {\n        this.container = $('<div class=\"pinch-zoom-container\"></div>');\n        this.el.before(this.container);\n        this.container.append(this.el);\n        this.container.css({\n          'overflow': 'hidden',\n          'position': 'relative'\n        });\n        this.el.css({\n          '-webkit-transform-origin': '0% 0%',\n          '-moz-transform-origin': '0% 0%',\n          '-ms-transform-origin': '0% 0%',\n          '-o-transform-origin': '0% 0%',\n          'transform-origin': '0% 0%',\n          'position': 'absolute'\n        });\n      },\n      end: function end() {\n        this.hasInteraction = false;\n        this.sanitize();\n        this.update();\n      },\n      bindEvents: function bindEvents() {\n        detectGestures(this.container.get(0), this);\n        $(window).on('resize', this.update.bind(this));\n        $(this.el).find('img').on('load', this.update.bind(this));\n      },\n      update: function update() {\n        if (this.updatePlaned) {\n          return;\n        }\n\n        this.updatePlaned = true;\n        setTimeout(function () {\n          this.updatePlaned = false;\n          this.updateAspectRatio();\n\n          var zoomFactor = this.getInitialZoomFactor() * this.zoomFactor,\n              offsetX = -this.offset.x / zoomFactor,\n              offsetY = -this.offset.y / zoomFactor,\n              transform3d = 'scale3d(' + zoomFactor + ', ' + zoomFactor + ',1) ' + 'translate3d(' + offsetX + 'px,' + offsetY + 'px,0px)',\n              transform2d = 'scale(' + zoomFactor + ', ' + zoomFactor + ') ' + 'translate(' + offsetX + 'px,' + offsetY + 'px)',\n              removeClone = function () {\n            if (this.clone) {\n              this.clone.remove();\n              delete this.clone;\n            }\n          }.bind(this);\n\n          if (!this.options.use2d || this.hasInteraction || this.inAnimation) {\n            this.is3d = true;\n            removeClone();\n            this.el.css({\n              '-webkit-transform': transform3d,\n              '-o-transform': transform2d,\n              '-ms-transform': transform2d,\n              '-moz-transform': transform2d,\n              'transform': transform3d\n            });\n          } else {\n            if (this.is3d) {\n              this.clone = this.el.clone();\n              this.clone.css('pointer-events', 'none');\n              this.clone.appendTo(this.container);\n              setTimeout(removeClone, 200);\n            }\n\n            this.el.css({\n              '-webkit-transform': transform2d,\n              '-o-transform': transform2d,\n              '-ms-transform': transform2d,\n              '-moz-transform': transform2d,\n              'transform': transform2d\n            });\n            this.is3d = false;\n          }\n        }.bind(this), 0);\n      },\n      enable: function enable() {\n        this.enabled = true;\n      },\n      disable: function disable() {\n        this.enabled = false;\n      }\n    };\n\n    var detectGestures = function detectGestures(el, target) {\n      var interaction = null,\n          fingers = 0,\n          lastTouchStart = null,\n          startTouches = null,\n          setInteraction = function setInteraction(newInteraction, event) {\n        if (interaction !== newInteraction) {\n          if (interaction && !newInteraction) {\n            switch (interaction) {\n              case \"zoom\":\n                target.handleZoomEnd(event);\n                break;\n\n              case 'drag':\n                target.handleDragEnd(event);\n                break;\n            }\n          }\n\n          switch (newInteraction) {\n            case 'zoom':\n              target.handleZoomStart(event);\n              break;\n\n            case 'drag':\n              target.handleDragStart(event);\n              break;\n          }\n        }\n\n        interaction = newInteraction;\n      },\n          updateInteraction = function updateInteraction(event) {\n        if (fingers === 2) {\n          setInteraction('zoom');\n        } else if (fingers === 1 && target.canDrag()) {\n          setInteraction('drag', event);\n        } else {\n          setInteraction(null, event);\n        }\n      },\n          targetTouches = function targetTouches(touches) {\n        return Array.prototype.slice.call(touches).map(function (touch) {\n          return {\n            x: touch.pageX,\n            y: touch.pageY\n          };\n        });\n      },\n          getDistance = function getDistance(a, b) {\n        var x, y;\n        x = a.x - b.x;\n        y = a.y - b.y;\n        return Math.sqrt(x * x + y * y);\n      },\n          calculateScale = function calculateScale(startTouches, endTouches) {\n        var startDistance = getDistance(startTouches[0], startTouches[1]),\n            endDistance = getDistance(endTouches[0], endTouches[1]);\n        return endDistance / startDistance;\n      },\n          cancelEvent = function cancelEvent(event) {\n        event.stopPropagation();\n        event.preventDefault();\n      },\n          detectDoubleTap = function detectDoubleTap(event) {\n        var time = new Date().getTime();\n\n        if (fingers > 1) {\n          lastTouchStart = null;\n        }\n\n        if (time - lastTouchStart < 300) {\n          cancelEvent(event);\n          target.handleDoubleTap(event);\n\n          switch (interaction) {\n            case \"zoom\":\n              target.handleZoomEnd(event);\n              break;\n\n            case 'drag':\n              target.handleDragEnd(event);\n              break;\n          }\n        }\n\n        if (fingers === 1) {\n          lastTouchStart = time;\n        }\n      },\n          firstMove = true;\n\n      el.addEventListener('touchstart', function (event) {\n        if (target.enabled) {\n          firstMove = true;\n          fingers = event.touches.length;\n          detectDoubleTap(event);\n        }\n      });\n      el.addEventListener('touchmove', function (event) {\n        if (target.enabled) {\n          if (firstMove) {\n            updateInteraction(event);\n\n            if (interaction) {\n              cancelEvent(event);\n            }\n\n            startTouches = targetTouches(event.touches);\n          } else {\n            switch (interaction) {\n              case 'zoom':\n                target.handleZoom(event, calculateScale(startTouches, targetTouches(event.touches)));\n                break;\n\n              case 'drag':\n                target.handleDrag(event);\n                break;\n            }\n\n            if (interaction) {\n              cancelEvent(event);\n              target.update();\n            }\n          }\n\n          firstMove = false;\n        }\n      });\n      el.addEventListener('touchend', function (event) {\n        if (target.enabled) {\n          fingers = event.touches.length;\n          updateInteraction(event);\n        }\n      });\n    };\n\n    return PinchZoom;\n  };\n\n  if (typeof define !== 'undefined' && define.amd) {\n    define(['jquery'], function ($) {\n      return definePinchZoom($);\n    });\n  } else {\n    window.RTP = window.RTP || {};\n    window.RTP.PinchZoom = definePinchZoom(window.$);\n  }\n}).call(this);",null]}